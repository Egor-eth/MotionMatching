#version 450
#define PS 1


#define USE_UV

struct Material
{
  #define LAMBERT
  #ifdef LAMBERT
  float Metallness;
  float Shininess;
#endif

#ifdef USE_UV
  vec2 uvScale;
  vec2 uvOffset;
#endif

};
struct VsOutput
{
  vec3 EyespaceNormal;
  vec3 WorldPosition;
#ifdef USE_UV
  vec2 UV;
#endif
};
struct Instance
{
    Material material;
    #if BONES
    mat4 Bones[BONES];
    #endif
    mat4 Model;
};
layout(std430, binding = 1) readonly buffer InstanceData 
{
    Instance instances[];
};
#ifdef VS
  #define material_inst instances[gl_InstanceID].material
#elif PS
  #define material_inst instances[instanceID].material
#endif
layout(std140, binding = 0) uniform Commondata 
{
    mat4 ViewProjection;
    mat4 ViewProjectionSkybox;
    vec3 CameraPosition;
    vec3 LightDirection;
    vec3 AmbientLight;
    vec3 SunLight;
    vec4 Time;
};



in VsOutput vsOutput;
flat in int instanceID;
out vec4 FragColor;

uniform sampler2D heightMap;
uniform sampler2D provincesMap;
uniform sampler2D normalMap;
uniform sampler2D treesMap;
uniform sampler2D riversMap;
uniform sampler2D terrainMap;

vec3 LightedColor(
    in vec3 color,
    in Material material,
    in vec3 world_position,
    in vec3 world_normal,
    in vec3 light_dir,
    in vec3 camera_pos)
{
    vec3 W = normalize(camera_pos - world_position);
    vec3 E = reflect(light_dir, world_normal);
    float df = max(0.0, dot(world_normal, -light_dir));
    float sf = max(0.0, dot(E, W));
    sf = pow(sf, material.Shininess);
    return color * (AmbientLight + df * SunLight) + vec3(1,1,1) * sf * material.Metallness;
}

vec3 apply_normal_map(vec3 normal_map, vec3 N, vec3 p, vec2 uv )
{
  // get edge vectors of the pixel triangle
  vec3 dp1 = dFdx(p);
  vec3 dp2 = dFdy(p);
  vec2 duv1 = dFdx(uv);
  vec2 duv2 = dFdy(uv);

  // solve the linear system
  vec3 dp2perp = cross(N, dp2);
  vec3 dp1perp = cross(dp1, N);
  vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
  vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

  vec2 TBlen = vec2(dot(T, T), dot(B, B));
  vec2 TBlenRcp = inversesqrt(TBlen);
  // construct a scale-invariant frame 
  return normal_map.z * normalize(N) + (normal_map.x * TBlenRcp.x) * T + (normal_map.y * TBlenRcp.y) * B;
}

void main()
{
  vec4 heigth = texture(heightMap, vsOutput.UV);
  vec4 tex = texture(provincesMap, vsOutput.UV);
  vec4 n = texture(normalMap, vsOutput.UV);
  vec4 trees = texture(treesMap, vsOutput.UV);
  vec4 rivers = texture(riversMap, vsOutput.UV);
  vec4 terrain = texture(terrainMap, vsOutput.UV);

  vec3 texColor = terrain.rgb;
  texColor = lerp(texColor, trees.rgb, trees.a);
  vec3 normalMap = texture(normalMap, vsOutput.UV).xyz * 2.0 - 1.0;
  vec3 normal = vsOutput.EyespaceNormal;
  normal = apply_normal_map(normalMap, vsOutput.EyespaceNormal, vsOutput.WorldPosition, vsOutput.UV);
  vec3 color = LightedColor(texColor, material_inst, vsOutput.WorldPosition, normal, LightDirection, CameraPosition);
  FragColor = vec4(color, 1.0);
}